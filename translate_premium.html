<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
	<meta content="utf-8" http-equiv="encoding" />
	<meta name="copyright" content="&copy; 2020 Steve Seguin" />
	<link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon" />
	<!-- Primary Meta Tags -->
	<title>CAPTION.Ninja - translate</title>
	<meta name="title" content="CAPTION.Ninja" />
	<meta name="description" content="This is a free-to-use captioning tool for OBS. Speech-to-text is done using Machine Learning" />
	<meta name="author" content="Steve Seguin" />

	
<style>
		@font-face {
		  font-family: 'Cousine';
		  src: url('fonts/Cousine-Bold.ttf') format('truetype');
		}
	
		:root {
		  --primary-color: #2498Eb;
		  --secondary-color: #2c3e50;
		  --background-color: #0000;
		  --text-color: #333;
		  --border-radius: 4px;
		  --cc-background: #000000;
		  --cc-text-color: #ffffff;
		  --cc-font-size: 24px;
		  --cc-line-height: 1.2;
		}

		body {
		  font-family: 'Arial', sans-serif;
		  line-height: 1.6;
		  color: var(--text-color);
		  background-color: var(--background-color);
		  margin: 0;
		  padding: 20px;
		}

		h3 {
		  color: var(--secondary-color);
		  border-bottom: 2px solid var(--primary-color);
		  padding-bottom: 10px;
		}

		a {
		  color: var(--primary-color);
		  text-decoration: none;
		  font-weight:600;
		  transition: color 0.3s ease;
		}

		a:hover {
		  color: var(--secondary-color);
		}

		.output {
			font-family: Cousine, monospace;
			margin-top:15px;
			color: black;
			min-height: 120px;
			font-size: 3.2em;
			line-height: 1.1em;
			letter-spacing: 0.0em;
			padding: 0em;
			padding-top:10px;
			text-shadow: 0.05em 0.05em 0px rgba(255,255,255,1);
		}
		
		.output span { 
			background-color: black; 
			padding: 8px 8px 0px 8px;
			margin:0;
		}

		/* Add this new style for the caption container */
		#caption-container {
		  position: relative;
		  width: 100%;
		  height: 200px; /* Adjust as needed */
		  overflow: hidden;
		  background-color: var(--cc-background);
		}

		select, input[type="checkbox"] {
		  margin: 10px 0;
		}

		select {
		  padding: 5px;
		  border-radius: var(--border-radius);
		  border: 1px solid #ddd;
		}

		label {
		  display: inline-block;
		  margin-right: 15px;
		}

		textarea {
		  width: 700px;
		  display:block;
		  padding: 10px;
		  border: 1px solid #ddd;
		  border-radius: var(--border-radius);
		  height: 70px;
		  resize: all;
		}
		
		#status {
		  margin-top: 10px;
		  font-style: italic;
		  color: var(--secondary-color);
		}

		#whosekey {
		  display: inline-block;
		  padding: 5px 10px;
		  border-radius: var(--border-radius);
		  font-weight: bold;
		}

		#whosekey[style*="yellow"] {
		  background-color: #ffeeba;
		  color: #856404;
		}

		#whosekey[style*="green"] {
		  background-color: #d4edda;
		  color: #155724;
		}

		/* Responsive design */
		@media (max-width: 768px) {
		  body {
			padding: 10px;
		  }
		  
		  textarea {
			width: calc(100% - 20px);
		  }
		  
		  .output span {
			font-size: calc(var(--cc-font-size) * 0.8);
		  }
		}
		
		.github {
			background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAd5JREFUOE+d1MurjlEUBvDfIZQZShEGmMhQiZGZlAlyK4eEAZHcyiVRyq1cUq5FwsD1MJGJiT/AzEzRcR8xMnGOW89pv9q9fScfe/J977o8e61nP2v16HzGYBWWYA4mlbBPeI5HuI9v7fSeDnircRqTh7msMX/ALtyr42rAEbiAzX8BaruTsx0/46gBL/0HWAMe0G01YNq8Xbz5PYuN2ISvCHc5oWEsruA69mJF8a0Mr6kwD/C64mw3zpSgCfjc6nE8vhRbAE+U/+8xI4DrcKNKOol9XfJ4CimgOb0BfIilxfIds/GyS8BZeIGRJf5BAN9gWjE8xcIuwZqwZ1hQPvoDOIBRxRCiN/wj4C30lpyBNmAmYNk/Aj7G4pIz2G75I6Y2Iu0CONwlZ2Ldcl+rqmjvWhdgCdmCi1Xs0KOsxc3C5WDhcw8uI9+dzugyVZFNw3/i1jTCfoVIJmo/VDiJeJ9gPX4U1CRHs4swrnXTO8xsZjlAd9GP+WU1zcPxckGde7WMZbvy5eirl8N5bMUxHMSvYdo9igMt3znsiK29vuLI1ojYU+2dwmWdnwv3V4YskozfUAGdFmzaz4KdgiM43KomNGTW32JnGd0/IZ0A48wrhpPMdFZ+feZievjqpILf7lRg3csIRqAAAAAASUVORK5CYII=");
			background-color: #FFF !important;
			width: 4px;
			height: 12px;
			background-repeat: no-repeat;
			display: inline-block;
			top: 2px;
			position: relative;
			left: 2px;
			filter: invert(100%);
			-webkit-filter: invert(100%);
		}
		div {
			display:block;
			
		}
	   .toggle-button {
		  background-color: var(--primary-color);
		  color: white;
		  border: none;
		  padding: 10px 20px;
		  border-radius: var(--border-radius);
		  cursor: pointer;
		  font-weight: bold;
		  transition: background-color 0.3s ease;
		  margin: 10px 0;
		}

		.toggle-button:hover {
		  background-color: var(--secondary-color);
		}

		.toggle-button.paused {
		  background-color: #dc3545;
		}
	</style>
</head>
<body>

	<h3>This is a premium version of the captioning tool, with enhanced speech-to-text transcription & language translation.</h3>
	
	The overlay-friendly output of the translated text is mirrored here: <a id="shareLink" href="overlay.html" target='_blank'>*ERROR GENERATING LINK*</a>.
	<br /><br />
	To use this app, accept the microphone permissions on page load and then just say something outloud. Once working, enable the transcription.
	<br /><br />
	Please note that this app uses your default microphone as the audio input source. 
	You sometimes can change the default audio source via the browser's setting, but you can also change it at your system level by changing the default recording device. 
	You can also change audio sources by using a Virtual Audio Cable, <a href='https://www.vb-audio.com/Cable/'> such as this one.</a> 
	Using it, it becomes possible to select other sources, including microphones, speakers, and other applications.
	<br /><br />
	The translation is powered by Google Cloud Translation, which <a href='https://console.cloud.google.com/apis/api/translate.googleapis.com/credentials' target="_blank">requires an API key. Get yours here.</a> Once you have it, add <b>&key=xxxxxxx</b> to this page's URL to set it. <br /><br /> You will need to get your own Google API key if you wish to use this premium version of the service. <a href='./translate'>The non-premium version is free of course.</a> Check out more options and details on <a href='https://github.com/steveseguin/captionninja'>GitHub</a>.
	<br /><br />
	<label>
	  From
	  <select id="lang-from" title="Set input language via the URL `&lang=en-US` option" name="from" class="lang-select"></select>
	</label>
	<label>
	  To
	  <select id="lang-to" name="to" class="lang-select"></select>
	</label>
	 <label>
	 <input type="checkbox" id="fullContext" />
	 Translate with added context?
	</label>
	<label>
    <input type="checkbox" id="enabledTranscription" />
     <span style='color:green;'><b>Start</b></span> Translation Output (ðŸ’¸)
    </label>
    <label>
    <input type="checkbox" id="incrementalUpdates" />
     Enable incremental updates (ðŸ’¸ðŸ’¸ðŸ’¸)
    </label>
	<button id="toggleTranscription" class="toggle-button">Pause Transcription</button>
    <span id="whosekey"></span>
	 <br /><br />
	<div class="footer" id="status"></div>
	<textarea id="input" name="input"></textarea>
	<br />
	<div id="output" class="output"></div>
	
<script>
(function (w) {
	w.URLSearchParams = w.URLSearchParams || function (searchString) {
		var self = this;
		self.searchString = searchString;
		self.get = function (name) {
			var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(self.searchString);
			if (results == null) {
				return null;
			}
			else {
				return decodeURI(results[1]) || 0;
			}
		};
	};
})(window);
var urlParams = new URLSearchParams(window.location.search);
let version;
const status = function(message){document.getElementById("status").innerText = message;}
var apiKey = "";
var langs = {
    "aa": "Afar",
    "ab": "Abkhazian",
    "ae": "Avestan",
    "af": "Afrikaans",
    "ak": "Akan",
    "am": "Amharic",
    "an": "Aragonese",
    "ar": "Arabic",
    "as": "Assamese",
    "av": "Avaric",
    "ay": "Aymara",
    "az": "Azerbaijani",
    "ba": "Bashkir",
    "be": "Belarusian",
    "bg": "Bulgarian",
    "bh": "Bihari languages",
    "bi": "Bislama",
    "bm": "Bambara",
    "bn": "Bengali",
    "bo": "Tibetan",
    "br": "Breton",
    "bs": "Bosnian",
    "ca": "Catalan; Valencian",
    "ce": "Chechen",
    "ch": "Chamorro",
    "co": "Corsican",
    "cr": "Cree",
    "cs": "Czech",
    "cu": "Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic",
    "cv": "Chuvash",
    "cy": "Welsh",
    "da": "Danish",
    "de": "German",
    "dv": "Divehi; Dhivehi; Maldivian",
    "dz": "Dzongkha",
    "ee": "Ewe",
    "el": "Greek, Modern (1453-)",
    "en": "English",
    "eo": "Esperanto",
    "es": "Spanish; Castilian",
    "et": "Estonian",
    "eu": "Basque",
    "fa": "Persian",
    "ff": "Fulah",
    "fi": "Finnish",
    "fj": "Fijian",
    "fo": "Faroese",
    "fr": "French",
    "fy": "Western Frisian",
    "ga": "Irish",
    "gd": "Gaelic; Scomttish Gaelic",
    "gl": "Galician",
    "gn": "Guarani",
    "gu": "Gujarati",
    "gv": "Manx",
    "ha": "Hausa",
    "he": "Hebrew",
    "hi": "Hindi",
    "ho": "Hiri Motu",
    "hr": "Croatian",
    "ht": "Haitian; Haitian Creole",
    "hu": "Hungarian",
    "hy": "Armenian",
    "hz": "Herero",
    "ia": "Interlingua (International Auxiliary Language Association)",
    "id": "Indonesian",
    "ie": "Interlingue; Occidental",
    "ig": "Igbo",
    "ii": "Sichuan Yi; Nuosu",
    "ik": "Inupiaq",
    "io": "Ido",
    "is": "Icelandic",
    "it": "Italian",
    "iu": "Inuktitut",
    "ja": "Japanese",
    "jv": "Javanese",
    "ka": "Georgian",
    "kg": "Kongo",
    "ki": "Kikuyu; Gikuyu",
    "kj": "Kuanyama; Kwanyama",
    "kk": "Kazakh",
    "kl": "Kalaallisut; Greenlandic",
    "km": "Central Khmer",
    "kn": "Kannada",
    "ko": "Korean",
    "kr": "Kanuri",
    "ks": "Kashmiri",
    "ku": "Kurdish",
    "kv": "Komi",
    "kw": "Cornish",
    "ky": "Kirghiz; Kyrgyz",
    "la": "Latin",
    "lb": "Luxembourgish; Letzeburgesch",
    "lg": "Ganda",
    "li": "Limburgan; Limburger; Limburgish",
    "ln": "Lingala",
    "lo": "Lao",
    "lt": "Lithuanian",
    "lu": "Luba-Katanga",
    "lv": "Latvian",
    "mg": "Malagasy",
    "mh": "Marshallese",
    "mi": "Maori",
    "mk": "Macedonian",
    "ml": "Malayalam",
    "mn": "Mongolian",
    "mr": "Marathi",
    "ms": "Malay",
    "mt": "Maltese",
    "my": "Burmese",
    "na": "Nauru",
    "nb": "BokmÃ¥l, Norwegian; Norwegian BokmÃ¥l",
    "nd": "Ndebele, North; North Ndebele",
    "ne": "Nepali",
    "ng": "Ndonga",
    "nl": "Dutch; Flemish",
    "nn": "Norwegian Nynorsk; Nynorsk, Norwegian",
    "no": "Norwegian",
    "nr": "Ndebele, South; South Ndebele",
    "nv": "Navajo; Navaho",
    "ny": "Chichewa; Chewa; Nyanja",
    "oc": "Occitan (post 1500)",
    "oj": "Ojibwa",
    "om": "Oromo",
    "or": "Oriya",
    "os": "Ossetian; Ossetic",
    "pa": "Panjabi; Punjabi",
    "pi": "Pali",
    "pl": "Polish",
    "ps": "Pushto; Pashto",
    "pt": "Portuguese",
    "qu": "Quechua",
    "rm": "Romansh",
    "rn": "Rundi",
    "ro": "Romanian; Moldavian; Moldovan",
    "ru": "Russian",
    "rw": "Kinyarwanda",
    "sa": "Sanskrit",
    "sc": "Sardinian",
    "sd": "Sindhi",
    "se": "Northern Sami",
    "sg": "Sango",
    "si": "Sinhala; Sinhalese",
    "sk": "Slovak",
    "sl": "Slovenian",
    "sm": "Samoan",
    "sn": "Shona",
    "so": "Somali",
    "sq": "Albanian",
    "sr": "Serbian",
    "ss": "Swati",
    "st": "Sotho, Southern",
    "su": "Sundanese",
    "sv": "Swedish",
    "sw": "Swahili",
    "ta": "Tamil",
    "te": "Telugu",
    "tg": "Tajik",
    "th": "Thai",
    "ti": "Tigrinya",
    "tk": "Turkmen",
    "tl": "Tagalog",
    "tn": "Tswana",
    "to": "Tonga (Tonga Islands)",
    "tr": "Turkish",
    "ts": "Tsonga",
    "tt": "Tatar",
    "tw": "Twi",
    "ty": "Tahitian",
    "ug": "Uighur; Uyghur",
    "uk": "Ukrainian",
    "ur": "Urdu",
    "uz": "Uzbek",
    "ve": "Venda",
    "vi": "Vietnamese",
    "vo": "VolapÃ¼k",
    "wa": "Walloon",
    "wo": "Wolof",
    "xh": "Xhosa",
    "yi": "Yiddish",
    "yo": "Yoruba",
    "za": "Zhuang; Chuang",
    "zh": "Chinese",
    "zu": "Zulu"
};
if (urlParams.has("key")){
	apiKey = urlParams.get("key") || "";
}
function getStorage(cname) {
	try {
		var itemStr = localStorage.getItem(cname);
	} catch(e){
		errorlog(e);
		return;
	}
	if (!itemStr) {
		return "";
	}
	let item = JSON.parse(itemStr);
	let now = new Date();
	if (now.getTime() > item.expiry) {
		localStorage.removeItem(cname);
		return "";
	}
	return item.value;
}
if (!apiKey && getStorage("apiKey")){
	apiKey = getStorage("apiKey");
} else if (apiKey){
	setStorage("apiKey", apiKey, 999999);
}
if (!apiKey){
	document.getElementById("whosekey").innerText = "(you'll need to specify own API key first to use)";
	document.getElementById("whosekey").style = "color: black; background-color: yellow;";
} else {
	document.getElementById("whosekey").innerText = "PRIVATE KEY ACTIVE";
	document.getElementById("whosekey").style = "color: white; background-color: green;";
}
function removeStorage(cname){
	localStorage.removeItem(cname);
}
function clearStorage(){
	localStorage.clear();
	if (!session.cleanOutput){
		warnUser("The local storage and saved settings have been cleared", 1000);
	}
}
function setStorage(cname, cvalue, hours=9999){
	let now = new Date();
	let item = {
		value: cvalue,
		expiry: now.getTime() + (hours * 60 * 60 * 1000),
	};
	try{
		localStorage.setItem(cname, JSON.stringify(item));
	}catch(e){errorlog(e);}
}
var myLang = navigator.language || "en-US";
if (urlParams.has("lang")){
	myLang = urlParams.get("lang");
} else if (getStorage("myLang")){
	myLang = getStorage("myLang");
} else {
	updateURL("lang="+myLang);
}
var myLangCode = myLang.split("-")[0].toLowerCase();
var targetCode = "de";
if (myLangCode == "de"){
	targetCode = "en";
}
if (getStorage("targetCode")){
	targetCode = getStorage("targetCode");
}
if (urlParams.has("translate") || urlParams.has("target")){
	targetCode = urlParams.get("translate") || urlParams.get("target") || targetCode;
	targetCode = targetCode.split("-")[0].toLowerCase();
} else if (getStorage("targetCode")){
	targetCode = getStorage("targetCode");
} else {
	updateURL("translate="+targetCode);
}
setStorage("targetCode", targetCode, 999999)
setStorage("myLang", myLang, 999999);
var label = false;
if (urlParams.has("label")){
	label = urlParams.get("label");
}
let isPaused = false;
const toggleButton = document.getElementById('toggleTranscription');

toggleButton.addEventListener('click', () => {
  isPaused = !isPaused;
  
  if (isPaused) {
	recognition.stop();
	toggleButton.textContent = 'Resume Transcription';
	toggleButton.classList.add('paused');
  } else {
	recognition.start();
	toggleButton.textContent = 'Pause Transcription';
	toggleButton.classList.remove('paused');
  }
});
var counter = 0;
let activeRequest = null;
let requestTimeout = null;
let lastRequestTime = 0;
const REQUEST_TIMEOUT = 3000;
const langFrom = document.getElementById("lang-from");
const langTo = document.getElementById("lang-to");
var availableLangs = {};
if (apiKey){
	var langurl = "https://www.googleapis.com/language/translate/v2/languages?key=" + apiKey;
} else {
	var langurl = "https://captionninjapremium.vdo.workers.dev/?ts="+Date.now();
}
fetch(langurl, {
	method: 'GET',
	headers: {
		'Content-Type': 'application/json',
		'Accept': 'application/json'
	}
}).then((response) => response.json()).then((data) => {
	console.log(data);
	if (data.error){
		alert(data.error.message);
		return;
	}
	var languages = data.data.languages;
	languages.forEach(l=>{
		availableLangs[l.language] = langs[l.language] || l.language;
		var option = document.createElement("option");
		option.innerText = langs[l.language] || l.language;
		option.value = l.language;
		if (option.value == myLangCode){
			option.selected = true;
		}
		langFrom.appendChild(option);
		option = document.createElement("option");
		option.innerText = langs[l.language] || l.language;
		option.value = l.language;
		if (option.value == targetCode){
			option.selected = true;
		}
		langTo.appendChild(option);
	});
	setup();
});
const getCachedTranslation = (url) => {
    try {
        const cached = localStorage.getItem('translation_' + url);
        if (cached) {
            const { data, timestamp } = JSON.parse(cached);
            if (Date.now() - timestamp < 24 * 60 * 60 * 1000) {
                return data?.translations?.[0]?.translatedText || null;
            }
            localStorage.removeItem('translation_' + url);
        }
    } catch (e) {
        console.error('Cache error:', e);
    }
    return null;
};
function cacheTranslation(url, data) {
  try {
  console.log("cacheTranslation");
    localStorage.setItem('translation_' + url, JSON.stringify({
      data: data,
      timestamp: Date.now()
    }));
  } catch (e) {
    console.error('Cache storage error:', e);
    try {
      const keys = Object.keys(localStorage);
      for (let key of keys) {
        if (key.startsWith('translation_')) {
          localStorage.removeItem(key);
        }
      }
    } catch (e) {
      console.error('Cache cleanup error:', e);
    }
  }
}
let lastRequest = {
    text: null,
    timestamp: 0,
    translation: null
};
const RATE_LIMIT = {
    minTimeBetweenRequests: 250,
    lastRequestTime: 0
};
async function translateIncremental(textToTranslate) {
    if (!textToTranslate?.trim() || !document.getElementById("enabledTranscription").checked) {
        return;
    }
    const incrementalEnabled = document.getElementById("incrementalUpdates").checked;
    const useContext = document.getElementById("fullContext").checked;
    if (textToTranslate === lastRequest.text) {
        const timeSinceLastRequest = Date.now() - lastRequest.timestamp;
        if (timeSinceLastRequest < 2000) {
            console.log('Skipping duplicate request:', textToTranslate);
            if (lastRequest.translation) {
                updateTrans(lastRequest.translation, incrementalEnabled);
            }
            return;
        }
    }
    const now = Date.now();
    const timeSinceLastRequest = now - RATE_LIMIT.lastRequestTime;
    if (timeSinceLastRequest < RATE_LIMIT.minTimeBetweenRequests) {
        const delayNeeded = RATE_LIMIT.minTimeBetweenRequests - timeSinceLastRequest;
        await new Promise(resolve => setTimeout(resolve, delayNeeded));
    }
    RATE_LIMIT.lastRequestTime = now;
    if (activeRequest) {
        activeRequest.abort();
        activeRequest = null;
    }
    if (requestTimeout) {
        clearTimeout(requestTimeout);
        requestTimeout = null;
    }
    const url = apiKey
        ? `https://www.googleapis.com/language/translate/v2/?key=${apiKey}&q=${encodeURI(textToTranslate)}&target=${targetCode}&source=${myLangCode}`
        : `https://captionninjapremium.vdo.workers.dev/?ts=${Date.now()}&q=${encodeURI(textToTranslate)}&target=${targetCode}&source=${myLangCode}`;
    const cachedData = getCachedTranslation(url);
    if (cachedData) {
        console.log('Using cached translation for:', textToTranslate);
        lastRequest = {
            text: textToTranslate,
            timestamp: Date.now(),
            translation: cachedData
        };
        updateTrans(cachedData, incrementalEnabled);
        return;
    }
    const controller = new AbortController();
    activeRequest = controller;
    lastRequestTime = Date.now();
    requestTimeout = setTimeout(() => {
        if (activeRequest === controller) {
            console.log('Request timeout for:', textToTranslate);
            controller.abort();
            activeRequest = null;
            requestTimeout = null;
        }
    }, REQUEST_TIMEOUT);
    try {
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            signal: controller.signal
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (!data?.data?.translations?.[0]) {
            throw new Error('Invalid response format from translation service');
        }
        const translatedText = data.data.translations[0].translatedText;
        cacheTranslation(url, data.data);
        lastRequest = {
            text: textToTranslate,
            timestamp: Date.now(),
            translation: translatedText
        };
        updateTrans(translatedText, incrementalEnabled);
    } catch (error) {
        if (error.name === 'AbortError') {
            console.log('Request was aborted');
            return;
        }
        console.error('Translation error:', error);
        if (error.message.includes('HTTP error! status: 429')) {
            const checkbox = document.getElementById("incrementalUpdates");
            if (checkbox?.checked) {
                checkbox.checked = false;
                alert('Incremental updates have been automatically disabled due to rate limiting.');
            }
            RATE_LIMIT.minTimeBetweenRequests *= 2;
        }
        const now = Date.now();
        if (!window.lastErrorTime || (now - window.lastErrorTime) > 5000) {
            window.lastErrorTime = now;
            handleTranslationError(error);
        }
        if (incrementalEnabled && window.lastSuccessfulTranslation) {
            updateTrans(window.lastSuccessfulTranslation, true);
        }
    } finally {
        if (activeRequest === controller) {
            activeRequest = null;
        }
        if (requestTimeout) {
            clearTimeout(requestTimeout);
            requestTimeout = null;
        }
    }
}
function handleTranslationError(error) {
    if (error instanceof TypeError && error.message.includes('CORS')) {
        alert('CORS Error: Unable to access the translation service.\n\n' +
              '1. Missing or invalid API key\n' +
              '2. Browser security restrictions\n' +
              '3. Service being temporarily unavailable\n\n' +
              'Please check your API key or try again later.');
    } else if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
        alert('Network Error: Unable to connect to the translation service.\n\n' +
              'This might be due to:\n' +
              '1. No internet connection\n' +
              '2. Website / IP denied access (CORS)\n' +
              '3. Missing or invalid API key\n' +
              '4. Service being down\n' +
              'Please check your internet connection and try again.');
    } else if (error.message.includes('HTTP error! status: 403')) {
        alert('Authorization Error: Unable to access the translation service.\n\n' +
              'This is likely due to:\n' +
              '1. Invalid API key\n' +
              '2. API key not having proper permissions\n' +
              '3. API quota exceeded\n\n' +
              'Please check your API key configuration.');
    } else if (error.message.includes('HTTP error! status: 429')) {
        alert('Rate Limit Error: Too many requests to the translation service.\n\n' +
              'Please wait a moment before trying again.\n\n' +
              'Consider disabling incremental updates to reduce API calls.');
    } else if (error.message.includes('Invalid response format')) {
        alert('Error: Received an unexpected response from the translation service.\n\n' +
              'Please try again later or contact support if the issue persists.');
    } else {
        alert('Translation Error: ' + error.message + '\n\n' +
              'Please try again later or contact support if the issue persists.\n\n' +
              'If this persists, try disabling incremental updates.');
    }
}
function updateTrans(translatedText, isIncremental) {
	window.lastSuccessfulTranslation = translatedText;
	document.getElementById("output").innerHTML = translatedText;
	var text = document.getElementById("output").textContent || "";
	counter += 1;
	if (label) {
		socket.send(JSON.stringify({
			"msg": true,
			[isIncremental ? "interm" : "final"]: text,
			"id": counter,
			"label": label,
			"c": document.getElementById("fullContext").checked,
			"ln": targetCode
		}));
	} else {
		socket.send(JSON.stringify({
			"msg": true,
			[isIncremental ? "interm" : "final"]: text,
			"id": counter,
			"c": document.getElementById("fullContext").checked,
			"ln": targetCode
		}));
	}
}
langFrom.addEventListener("change", e => {
	myLangCode = e.target.value;
	console.log("Source language changed to:", myLangCode);
	
	// Always update storage and URL, regardless of previous language
	setStorage("myLang", myLangCode, 999999);
	updateURL("lang="+myLangCode, true);
	
	// Always restart recognition with new language
	if (recognition) {
		recognition.onend = null;
		recognition.stop();
		recognition = null;
	}
	myLang = myLangCode; // Update the myLang variable directly
	setup();
});
langTo.addEventListener("change", e => {
	targetCode = e.target.value;
	console.log("Target language changed to:", targetCode);
	updateURL("translate="+targetCode, true);
	setStorage("targetCode", targetCode, 999999);
	
	// If there's text in the input field, translate it immediately with the new target language
	const currentText = document.getElementById("input").value.trim();
	if (currentText && document.getElementById("enabledTranscription").checked) {
		if (document.getElementById("fullContext").checked) {
			let fullText = [];
			if (second_transcription?.trim()) {
				fullText.push(second_transcription.trim().replace(/\.?$/, '.'));
			}
			if (last_transcription?.trim()) {
				fullText.push(last_transcription.trim().replace(/\.?$/, '.'));
			}
			if (currentText?.trim()) {
				fullText.push(currentText.trim().replace(/\.?$/, '.'));
			}
			translateIncremental(fullText.join(' '));
		} else {
			translateIncremental(currentText);
		}
	}
});
function updateURL(param, force=false) {
	var para = param.split('=');
	if (!(urlParams.has(para[0].toLowerCase()))){
		if (history.pushState){
			var arr = window.location.href.split('?');
			var newurl;
			if (arr.length > 1 && arr[1] !== '') {
				newurl = window.location.href + '&' +param;
			} else {
				newurl = window.location.href + '?' +param;
			}
			window.history.pushState({path:newurl},'',newurl);
		}
	} else if (force){
		if (history.pushState){
			var href = new URL(window.location.href);
			if (para.length==1){
				href.searchParams.set(para[0].toLowerCase(), "");
			} else {
				href.searchParams.set(para[0].toLowerCase(), para[1]);
			}
			window.history.pushState({path:href.toString()},'',href.toString());
		}
	}
}
function generateStreamID(){
	var text = "";
	var possible = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789";
	for (var i = 0; i < 7; i++){
		text += possible.charAt(Math.floor(Math.random() * possible.length));
	}
	return text;
};
var roomID = "test";
if (urlParams.has("room")){
	roomID = urlParams.get("room");
} else if (urlParams.has("ROOM")){
	roomID = urlParams.get("ROOM");
} else {
	roomID = generateStreamID();
	updateURL("room="+roomID);
}
var url = document.URL.substr(0,document.URL.lastIndexOf('/'));
document.getElementById("shareLink").href= url+"/overlay?room="+roomID;
document.getElementById("shareLink").innerHTML = url+"/overlay?room="+roomID;
navigator.clipboard.writeText(url+"/overlay?room="+roomID).then(() => {
}, () => {
});

var socket;
let retryCount = 0;
const maxRetryDelay = 30000; // Maximum delay of 30 seconds
const baseDelay = 1000; // Start with 1 second delay after first immediate retry

function getRetryDelay() {
	if (retryCount === 0) {
		return 0; // First retry is immediate
	}
	// Exponential backoff: baseDelay * 2^(retryCount-1)
	const delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxRetryDelay);
	return delay;
}

function connectWebSocket() {
	if (socket) {
		socket.close();
		socket = null;
	}

	socket = new WebSocket("wss://api.caption.ninja:443");

	socket.onclose = function() {
		console.log("WebSocket connection closed. Attempting to reconnect...");
		const delay = getRetryDelay();
		console.log(`Reconnecting in ${delay}ms (attempt ${retryCount + 1})...`);
		setTimeout(connectWebSocket, delay);
		retryCount++;
	};

	socket.onopen = function() {
		console.log("WebSocket connected. Joining room...");
		// Reset retry count on successful connection
		retryCount = 0;
		socket.send(JSON.stringify({"join":roomID}));
	};

	socket.onerror = function(error) {
		console.error("WebSocket error:", error);
		if (socket) {
			socket.close();
			socket = null;
		}
		const delay = getRetryDelay();
		console.log(`Reconnecting in ${delay}ms (attempt ${retryCount + 1})...`);
		setTimeout(connectWebSocket, delay);
		retryCount++;
	};
}

connectWebSocket();

var final_transcript = '';
var last_transcription  = "";
var second_transcription = "";
var idle = null;
var recognition = null;
var ends = 0;
document.getElementById("incrementalUpdates").addEventListener("change", function(e) {
    if (recognition) {
		recognition.onend = null;
		recognition.stop();
		recognition = null;
		setup();
    }
});
var sanitize = function(string) {
	var temp = document.createElement('div');
	temp.textContent = string;
	return temp.textContent
		.substring(0, Math.min(temp.textContent.length, 500))
		.trim();
};
function setup(){
	if ('webkitSpeechRecognition' in window){
		console.log("Setting up webkitSpeechRecognition");
		recognition = new webkitSpeechRecognition();
		
		// Always use the current myLangCode
		recognition.lang = myLangCode || myLang || navigator.language || "en-US";
		console.log("Recognition language set to:", recognition.lang);
		
		recognition.continuous = true;
		recognition.interimResults = document.getElementById("incrementalUpdates").checked;
		recognition.onstart = function(){
			console.log("started transcription");
			setTimeout(function(){
				ends = 0;
			}, 2000);
		};
		recognition.onerror = function(event){
			console.error(event);
		};
		recognition.onend = function(e){
			if (isPaused){return;}
			console.log(e);
			console.log("Stopped transcription");

			// Save any pending transcript before restarting
			let currentInterim = document.getElementById("input").value.trim();
			if (currentInterim) {
				console.log("Processing interrupted transcript:", currentInterim);
				
				if (document.getElementById("fullContext").checked) {
					let fullText = [];
					if (second_transcription?.trim()) {
						fullText.push(second_transcription.trim().replace(/\.?$/, '.'));
					}
					if (last_transcription?.trim()) {
						fullText.push(last_transcription.trim().replace(/\.?$/, '.'));
					}
					fullText.push(currentInterim.trim().replace(/\.?$/, '.'));
					
					second_transcription = last_transcription;
					last_transcription = currentInterim.trim().replace(/\.?$/, '.') + ' ';
					
					translateIncremental(fullText.join(' '), false);
				} else {
					translateIncremental(currentInterim, false);
					last_transcription = currentInterim.trim().replace(/\.?$/, '.') + ' ';
				}
			}
			
			if (event.type === "end"){
				ends +=1;
			}
			if (ends > 3){
				alert("WARNING: Cannot enable transcription service...");
			} else {
				setTimeout(() => recognition.start(), 100); // Small delay before restart
			}
		};
		recognition.onresult = function(event) {
			let interim_transcript = '';
			if (typeof(event.results) == 'undefined') {
				console.log('Undefined results in event:', event);
				return;
			}
			for(var i = event.resultIndex; i < event.results.length; ++i){
				if(event.results[i].isFinal){
					final_transcript += sanitize(event.results[i][0].transcript);
				} else {
					interim_transcript += " " +sanitize(event.results[i][0].transcript);
					interim_transcript = interim_transcript.trim();
				}
			}
			if (final_transcript || (interim_transcript && document.getElementById("incrementalUpdates").checked)) {
				let currentText = final_transcript || interim_transcript;
				console.log("Processing text:", currentText, "Final:", !!final_transcript);
				if (document.getElementById("fullContext").checked) {
					let fullText = [];
					if (second_transcription?.trim()) {
						fullText.push(second_transcription.trim().replace(/\.?$/, '.'));
					}
					if (last_transcription?.trim()) {
						fullText.push(last_transcription.trim().replace(/\.?$/, '.'));
					}
					if (currentText?.trim()) {
						fullText.push(currentText.trim().replace(/\.?$/, '.'));
					}
					document.getElementById("input").value = fullText.join('\n');
					let contextText = fullText.join(' ');
					console.log("Translating with context:", contextText);
					translateIncremental(contextText);
				} else {
					document.getElementById("input").value = currentText;
					translateIncremental(currentText);
				}
				if (final_transcript) {
					if (currentText.trim()) {
						second_transcription = last_transcription;
						last_transcription = currentText.trim().replace(/\.?$/, '.') + ' ';
						final_transcript = '';
						console.log("Updated context state:", {
							second: second_transcription,
							last: last_transcription
						});
					}
				}
			}
		};
		if (isPaused){return;}
		recognition.start();
	}
}
</script>
</body>
</html>